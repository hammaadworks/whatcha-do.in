// lib/logic/JournalActivityService.ts
import { SupabaseClient } from '@supabase/supabase-js';
// import { Database } from '../supabase/types'; // Assuming types are generated by Supabase CLI
import { ActivityLogEntry, JournalEntry } from '../supabase/types'; // Using the types defined in lib/supabase/types
import { format } from 'date-fns';
import { withLogging } from '../logger/withLogging'; // Import withLogging HOF
import logger from '../logger/server'; // Import direct logger


type JournalUpsertPayload = Omit<JournalEntry, 'id' | 'created_at' | 'updated_at'> & {
  id?: string; // ID can be optional for upsert
};

export class JournalActivityService {
  private supabase: SupabaseClient<any>;
  private logger = logger.child({ service: 'JournalActivityService' });

  constructor(supabaseClient: SupabaseClient<any>) {
    this.supabase = supabaseClient;
  }

  /**
   * Fetches a journal entry for a given user, date, and privacy status.
   * Creates a new one if it doesn't exist.
   */
  private async _getOrCreateJournalEntry(
    userId: string,
    date: Date,
    isPublic: boolean
  ): Promise<JournalEntry> {
    const formattedDate = format(date, 'yyyy-MM-dd');
    this.logger.debug({ userId, formattedDate, isPublic }, 'Attempting to get or create journal entry.');

    const { data, error } = await this.supabase
      .from('journal_entries')
      .select('*')
      .eq('user_id', userId)
      .eq('entry_date', formattedDate)
      .eq('is_public', isPublic)
      .single();

    if (error && error.code !== 'PGRST116') { // PGRST116 means "no rows found"
      this.logger.error({ err: error, userId, formattedDate, isPublic }, 'Error fetching journal entry.');
      throw error;
    }

    if (data) {
      this.logger.debug({ journalEntryId: data.id }, 'Found existing journal entry.');
      return data as JournalEntry; // Type assertion as Supabase typings might be looser
    } else {
      // Create a new entry if not found
      const newEntryPayload: JournalUpsertPayload = {
        user_id: userId,
        entry_date: formattedDate,
        is_public: isPublic,
        content: '', // Start with empty content
        activity_log: [],
      };
      this.logger.info({ userId, formattedDate, isPublic }, 'Creating new journal entry.');
      const { data: newEntry, error: createError } = await this.supabase
        .from('journal_entries')
        .insert(newEntryPayload)
        .select('*')
        .single();

      if (createError) {
        this.logger.error({ 
          err: createError, 
          userId, 
          formattedDate, 
          isPublic,
          errorDetails: createError.message, // Add specific message
          errorCode: createError.code,      // Add specific code
          errorHint: createError.hint,      // Add hint if available
        }, 'Error creating new journal entry.');
        throw createError;
      }
      this.logger.info({ journalEntryId: newEntry.id }, 'Successfully created new journal entry.');
      return newEntry as JournalEntry;
    }
  }

  /**
   * Logs an activity to the journal's activity_log.
   * If the activity already exists (same id, type), it updates it.
   */
  private async _logActivity(
    userId: string,
    date: Date,
    entry: Omit<ActivityLogEntry, 'timestamp' | 'status'> & { status?: 'completed' | 'uncompleted'}
  ): Promise<void> {
    this.logger.info({ userId, date, entry }, 'Logging activity.');
    const journalEntry = await this._getOrCreateJournalEntry(userId, date, entry.is_public);
    const activityLog = journalEntry.activity_log || [];

    const existingIndex = activityLog.findIndex(
      (item) => item.id === entry.id && item.type === entry.type
    );

    const newLogEntry: ActivityLogEntry = {
      ...entry,
      timestamp: new Date().toISOString(), // Always use current time for logging
      status: entry.status || 'completed', // Default to completed if not specified
    };

    if (existingIndex > -1) {
      activityLog[existingIndex] = newLogEntry; // Update existing
      this.logger.debug({ activityId: entry.id, type: entry.type }, 'Updating existing activity log entry.');
    } else {
      activityLog.push(newLogEntry); // Add new
      this.logger.debug({ activityId: entry.id, type: entry.type }, 'Adding new activity log entry.');
    }

    const { error } = await this.supabase
      .from('journal_entries')
      .update({ activity_log: activityLog })
      .eq('id', journalEntry.id);

    if (error) {
      this.logger.error({ err: error, journalEntryId: journalEntry.id }, 'Error updating activity log in DB.');
      throw error;
    }
    this.logger.info({ activityId: entry.id, type: entry.type }, 'Activity successfully logged.');
  }

  /**
   * Removes an activity from the journal's activity_log.
   */
  private async _removeActivity(userId: string, date: Date, itemId: string, itemType: ActivityLogEntry['type'], isPublic: boolean): Promise<void> {
    this.logger.info({ userId, date, itemId, itemType, isPublic }, 'Removing activity.');
    const journalEntry = await this._getOrCreateJournalEntry(userId, date, isPublic);
    let activityLog = journalEntry.activity_log || [];

    const initialLength = activityLog.length;
    activityLog = activityLog.filter(
      (item) => !(item.id === itemId && item.type === itemType)
    );

    if (activityLog.length < initialLength) { // Only update if something was actually removed
      this.logger.debug({ itemId, itemType }, 'Found and removing activity from log.');
      const { error } = await this.supabase
        .from('journal_entries')
        .update({ activity_log: activityLog })
        .eq('id', journalEntry.id);

      if (error) {
        this.logger.error({ err: error, journalEntryId: journalEntry.id }, 'Error removing activity from log in DB.');
        throw error;
      }
      this.logger.info({ itemId, itemType }, 'Activity successfully removed.');
    } else {
      this.logger.debug({ itemId, itemType }, 'Activity not found in log, no removal needed.');
    }
  }

  /**
   * Fetches the activity log for a specific date and privacy status.
   */
  private async _getActivitiesForDate(userId: string, date: Date, isPublic: boolean): Promise<ActivityLogEntry[]> {
    const formattedDate = format(date, 'yyyy-MM-dd');
    this.logger.info({ userId, formattedDate, isPublic }, 'Fetching activities for date.');
    const { data, error } = await this.supabase
      .from('journal_entries')
      .select('activity_log')
      .eq('user_id', userId)
      .eq('entry_date', formattedDate)
      .eq('is_public', isPublic)
      .single();

    if (error && error.code !== 'PGRST116') {
      this.logger.error({ err: error, userId, formattedDate, isPublic }, 'Error fetching activities for date.');
      throw error;
    }

    const activities = (data?.activity_log as ActivityLogEntry[]) || [];
    this.logger.info({ count: activities.length }, 'Successfully fetched activities for date.');
    return activities;
  }

  /**
   * Updates the habit name in activity log entries within the journal.
   * Finds all journal entries for a user that contain the old habit name
   * and replaces it with the new habit name for entries of type 'habit'
   * and matching habitId.
   *
   * @param userId - The ID of the user.
   * @param habitId - The ID of the habit being renamed.
   * @param oldHabitName - The previous name of the habit.
   * @param newHabitName - The new name of the habit.
   */
  private async _updateHabitNameInJournal(
    userId: string,
    habitId: string,
    oldHabitName: string,
    newHabitName: string
  ): Promise<void> {
    this.logger.info({ userId, habitId, oldHabitName, newHabitName }, 'Updating habit name in journal entries.');

    // Fetch today's journal entry for the user
    const today = new Date(); // Assuming "today's activity" refers to the current date
    const formattedDate = format(today, 'yyyy-MM-dd');

    // We need to fetch both public and private journal entries
    // Using Promise.allSettled to ensure both are attempted even if one fails or doesn't exist
    const [publicEntryResult, privateEntryResult] = await Promise.allSettled([
      this.supabase.from('journal_entries').select('*').eq('user_id', userId).eq('entry_date', formattedDate).eq('is_public', true).single(),
      this.supabase.from('journal_entries').select('*').eq('user_id', userId).eq('entry_date', formattedDate).eq('is_public', false).single(),
    ]);

    const entriesToUpdate: JournalEntry[] = [];
    if (publicEntryResult.status === 'fulfilled' && publicEntryResult.value.data) {
        entriesToUpdate.push(publicEntryResult.value.data as JournalEntry);
    }
    if (privateEntryResult.status === 'fulfilled' && privateEntryResult.value.data) {
        entriesToUpdate.push(privateEntryResult.value.data as JournalEntry);
    }
    
    for (const journalEntry of entriesToUpdate) {
        let activityLog = journalEntry.activity_log || [];
        let needsUpdate = false;

        const updatedActivityLog = activityLog.map(activity => {
            // Ensure `activity.id` and `activity.description` are treated as strings
            if (activity.type === 'habit' && String(activity.id) === habitId && String(activity.description) === oldHabitName) {
                needsUpdate = true;
                return { ...activity, description: newHabitName };
            }
            return activity;
        });

        if (needsUpdate) {
            const { error } = await this.supabase
                .from('journal_entries')
                .update({ activity_log: updatedActivityLog })
                .eq('id', journalEntry.id);

            if (error) {
                this.logger.error({ err: error, journalEntryId: journalEntry.id, userId, habitId, oldHabitName, newHabitName }, 'Error updating habit name in journal entry.');
                throw error;
            }
            this.logger.debug({ journalEntryId: journalEntry.id, userId, habitId }, 'Successfully updated habit name in journal entry.');
        }
    }
  }

  // Wrapped public methods for logging
  public getOrCreateJournalEntry = withLogging(this._getOrCreateJournalEntry.bind(this), 'JournalActivityService.getOrCreateJournalEntry');
  public logActivity = withLogging(this._logActivity.bind(this), 'JournalActivityService.logActivity');
  public removeActivity = withLogging(this._removeActivity.bind(this), 'JournalActivityService.removeActivity');
  public getActivitiesForDate = withLogging(this._getActivitiesForDate.bind(this), 'JournalActivityService.getActivitiesForDate');
  public updateHabitNameInJournal = withLogging(this._updateHabitNameInJournal.bind(this), 'JournalActivityService.updateHabitNameInJournal');
}